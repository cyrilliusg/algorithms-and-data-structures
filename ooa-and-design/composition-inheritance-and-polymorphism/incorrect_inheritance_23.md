## Представим иерархию:

### Базовый класс ```Uploader```:

```python
class Uploader:

    def upload(file: File) -> str:
        """
        Предусловие: file не пустой (имеет ненулевой размер).
        Постусловие: возвращается URL загруженного файла в виде строки (например, "http://localhost/file_name").
        """
```
### Класс-наследник ```LimitedUploader```:

```python
class LimitedUploader(Uploader):
    def __init__(self):
        self.__max_size: int = -1  # максимальный размер загружаемого файла

    def upload(self, file: File) -> str | None:
        # Пример неверного усиления предлусловия
        if file.size <= self.__max_size:
            # Пример неверного ослабления постусловия
            return None
```

#### Пример неверного усиления предусловия:
Если прямо в метод добавить проверку на max_size, то любой код, работающий с переменной типа Uploader, 
при передаче в неё LimitedUploader может не пройти эту новую проверку и получить ошибку ― 
хотя в спецификации Uploader предусловие всегда истинно для всех непустых файлов.


#### Пример неверного ослабления постусловия:
Если в этой же проверке с неудачным предусловием сделать так, чтобы при неудачном лимите upload возвращал пустую строку "" или None, то клиент,
ожидающий гарантированный валидный URL, получит некорректный результат и сломает логику, используя это значение дальше.


#### Как можно было бы сделать правильно:

- Не менять предусловие метода upload: оставляем разрешённым любой непустой файл.
- Не менять постусловие: всегда возвращаем непустую строку-URL.
- Лимит проверять отдельным методом:

```python
# К примеру ввести метод is_within_limit
if uploader.is_within_limit(file):
    url = uploader.upload(file)
```