## Политика скрытия методов при наследовании


1. **метод публичен в родительском классе А и публичен в его потомке B**.

   Данный вариант доступен по умолчанию:
   ```python
   class A:
       def foo(self):
           print("class: A")

   class B(A):
       pass

   b = B()
   b.foo()  # class: A
   ```

2. **метод публичен в родительском классе А и скрыт в его потомке B**  
   В чистом виде такое сделать нельзя. Как варианет -- можно переопределить в дочернем и вызвать исключение:

```python
class A:
    def foo(self):
        print("class: A")


class B(A):
    def foo(self):
        raise AttributeError("foo нельзя использовать")


b = B()
b.foo()  # AttributeError: foo скрыт в B 
```

Но, он всё равно будет доступен к вызову.

3. **метод скрыт в родительском классе А и публичен в его потомке B**

   Если метод жестко скрыт (две '__' в начале наименования), то к нему обращаться нельзя вовсе. Если же сделать
   одну '_' (рекомендательно скрытые), то, так сделать можно.

```python
class A:
    def _foo(self):
        print("class: A")


class B(A):
    def foo(self):
        return self._foo()  # допустимо


b = B()
b.foo()  # A._foo (скрытый)
```

4. **метод скрыт в родительском классе А и скрыт в его потомке B**

   Аналогично п.3: в таком случае, у родительского должна быть одна '_' в начале наименования. У дочернего - на
   усмотрение проектировщика. Можно жестко скрыть ('__'), а можно порекомендовать не переиспользовать ('_').

```python
class A:

    def _foo(self):
        print("class: A")


class B(A):

    def _foo(self):  # переопределен, но так же скрыт
        print("class: B")


b = B()
b._foo()  # B._foo (скрытый)
```